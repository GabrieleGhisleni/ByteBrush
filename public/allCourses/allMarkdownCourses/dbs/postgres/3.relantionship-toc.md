

<!-- toc -->

- [Relationship](#relationship)
  * [Primary key](#primary-key)
    + [Multiple columns as primary key](#multiple-columns-as-primary-key)
    + [Auto Generated Primary Key](#auto-generated-primary-key)
  * [Foreign key](#foreign-key)
    + [Creating a foreign key](#creating-a-foreign-key)
    + [Querying data using a foreign key](#querying-data-using-a-foreign-key)
    + [Foreign key insert consistency](#foreign-key-insert-consistency)
    + [Foreign key deleting consistency](#foreign-key-deleting-consistency)
  * [How to define a schema](#how-to-define-a-schema)
  * [Unique key and null values](#unique-key-and-null-values)
  * [Types of relations](#types-of-relations)
    + [One-to-One](#one-to-one)
    + [One-to-Many](#one-to-many)
    + [Many-to-Many](#many-to-many)
    + [Best practise for creating table](#best-practise-for-creating-table)
  * [Normalization](#normalization)

<!-- tocstop -->

## Relationship

A relational schema in a database is the blueprint that outlines the way data is organized into tables. It defines how data is stored in a relational database and includes information about tables, fields, relationships, indexes, and keys.

A relational schema is a set of relations (or tables) that are related to each other by a set of attributes (or columns). The relations are connected by a set of foreign keys that point to the primary keys of other relations.

[schema](./images/schema.png)

### Primary key

The primary key is a column or a set of columns in a table that uniquely identifies each row in that table. It is a fundamental aspect of database design and plays a crucial role in ensuring data integrity.


The primary key serves two main purposes:

1. Uniqueness: It ensures that each record within a table can be uniquely identified, preventing duplicate entries. This is critical in maintaining data integrity and accuracy.

2. Relationship: It establishes a link between tables in a relational database. This is essential for creating relationships and joining tables in queries.

Core Components of Primary Key in SQL

1. Uniqueness: A primary key value must be unique. This means that no two rows in a table can have the same primary key value. If you try to insert a row with a primary key value that already exists in the table, SQL will return an error.

2. Not Null: A primary key value cannot be null. This is because the primary key's purpose is to uniquely identify each record in a table. If null values were allowed, it would be possible to have multiple records without a valid identifier.

3. Immutable: Once a primary key is set for a row, it should not be changed. This is to maintain referential integrity in the database. If primary key values were allowed to change, it could result in broken references between tables.

4. Index: SQL automatically creates an index for the primary key. This speeds up data retrieval, as the database can use the index to quickly locate a record without having to scan the entire table.

To query using a primary key, you can use the `WHERE` clause to filter the results by the primary key value. For example, to get the name of a particular employee given their ID, you can use the following query:

```sql
SELECT name
FROM employees
WHERE id = 1;
```


#### Multiple columns as primary key

A primary key is a column or a set of columns in a table that uniquely identifies each row in that table. It is a fundamental aspect of database design and plays a crucial role in ensuring data integrity.

recall: you cannot have two rows with the same primary key value. This means that if you have a table with a single column primary key, you cannot have two rows with the same value in that column. However, if you have a table with a composite primary key, you can have two rows with the same value in one column as long as they have different values in the other column(s).

#### Auto Generated Primary Key

An auto-generated primary key is a primary key that is automatically generated by the database. It is usually an integer value that is incremented by one for each new record inserted into the table. This ensures that each record has a unique identifier, and it also makes it easier to insert new records into the table.

To create an auto-generated primary key, you can use the `SERIAL` data type in PostgreSQL. This data type is an alias for `INTEGER` that automatically generates a sequence of integers starting from 1. For example, to create a table with an auto-generated primary key, you can use the following query:
To mark a column as a primary key, you can use the `PRIMARY KEY` constraint in the `CREATE TABLE` statement. For example, to create a table with an auto-generated primary key, you can use the following query:

```sql
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);
```

In this example, the "id" column is defined as a SERIAL data type, which means that it will automatically generate a sequence of integers starting from 1. The "id" column is also defined as the primary key of the table, which means that it will uniquely identify each record in the table.

### Foreign key

A foreign key in SQL is a fundamental concept in the realm of relational databases. It is a field (or collection of fields) in one table, that is used to link to the primary key in another table. The table containing the foreign key is called the child table, and the table containing the primary key is called the parent table.

The main purpose of a foreign key is to ensure referential integrity of the data. In other words, it prevents actions that would destroy links between tables. It also prevents invalid data from being inserted into the foreign key column, because it has to be one of the values contained in the table it points to.

Core Components of Foreign Key in SQL

1. Parent Table: This is the table that the foreign key references. It contains the primary key that the foreign key in the child table points to.
2. Child Table: This is the table that contains the foreign key. The foreign key in this table points to a primary key in the parent table.
3. Primary Key: This is a unique identifier for a record in a table. A primary key cannot contain NULL values and it must contain unique values.
4. Foreign Key: This is a set of one or more columns that are used to establish a link between the data in two tables. The foreign key in the child table will generally reference a primary key in the parent table.
5. Referential Actions: These are actions that SQL takes when a user tries to delete or update a row to which a foreign key points. The actions can be set to NO ACTION, CASCADE, SET NULL, SET DEFAULT.

The foreign key could also point to a non primary key column in the parent table. This is called a unique key. A unique key is a column or a set of columns in a table that uniquely identifies each row in that table. It is similar to a primary key, but it can contain null values and it does not have to be unique.

#### Creating a foreign key

To create a foreign key in PostgreSQL, you can use the `REFERENCES` keyword in the `CREATE TABLE` statement. For example, to create a table with a foreign key that references the primary key of another table, you can use the following query:

```sql
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE employee_details (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER REFERENCES employees(id),
  hire_date DATE
);
```

In this example, the "employee_details" table has a foreign key called "employee_id" that references the "id" column of the "employees" table. The FOREIGN KEY constraint ensures that each set of employee details is unique and belongs to exactly one employee.

#### Querying data using a foreign key

To query using a foreign key, you can use the `JOIN` statement to combine data from multiple tables based on the foreign key constraint. For example, to get the name of a particular employee given their ID, you can use the following query:

```sql
SELECT employees.name
    FROM employees
    JOIN employee_details ON employees.id = employee_details.employee_id
WHERE employees.id = 1;
```

#### Foreign key insert consistency

When you try to insert a record with a foreign key value that does not exist in the parent table, PostgreSQL will return an error. This is because the foreign key constraint ensures that each value in the foreign key column must be one of the values contained in the parent table.

For example, if you try to insert a record into the "employee_details" table with an "employee_id" value of 100, PostgreSQL will return an error because there is no record in the "employees" table with an "id" value of 100.

#### Foreign key deleting consistency

It is possible to specify what postgres should do when a record in the parent table is deleted. This is called a referential action. There are four types of referential actions:

1. `ON DELETE  RESTRICT`: This is the default action. It prevents the deletion of a record in the parent table if there are any records in the child table that reference it.
2. `ON DELETE CASCADE`: This action deletes all records in the child table that reference the deleted record in the parent table.
3. `ON DELETE SET NULL`: This action sets the foreign key value in the child table to NULL if the record in the parent table is deleted.
4. `ON DELETE SET DEFAULT`: This action sets the foreign key value in the child table to the default value if the record in the parent table is deleted.
5. `ON DELETE NO ACTION`: This action does nothing if the record in the parent table is deleted.

You can specify the referential action when you create the foreign key constraint. For example, to create a foreign key with the `ON DELETE CASCADE` action, you can use the following query:

```sql
CREATE TABLE employee_details (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
  hire_date DATE
);
```


### How to define a schema

Let's break down the process of creating a relational schema step by step:

Step 1: Identify Entities
The first step in creating a relational schema is to identify the entities. Entities are the main objects or concepts in the system you're modeling. For example, if you're creating a database for a library, your entities might be Books, Authors, Publishers, and Readers.

Step 2: Define Attributes for Each Entity
Next, you need to define the attributes for each entity. Attributes are the properties or characteristics of an entity. For example, for the entity "Book", the attributes might be Title, ISBN, Publication Date, and Author.

Step 3: Identify Primary Keys
A primary key is a unique identifier for a record in a table. For the Book entity, the primary key could be the ISBN because each book has a unique ISBN.

Step 4: Identify Relationships
The next step is to identify the relationships between entities. There are three types of relationships in a relational database: one-to-one, one-to-many, and many-to-many. For example, one author can write many books, so there is a one-to-many relationship between Authors and Books.

Step 5: Create Tables
Now you can create tables for each entity. Each table should include the entity's attributes and primary key. For example, the Books table might include columns for ISBN, Title, Publication Date, and Author.

Step 6: Normalize the Database
Normalization is the process of organizing the columns and tables of a relational database to minimize data redundancy and improve data integrity. It involves dividing larger tables into smaller tables and defining relationships between them.

Step 7: Implement Relationships
The final step is to implement the relationships you identified earlier. This usually involves creating foreign keys. A foreign key is a field in a table that matches the primary key of another table. For example, in the Books table, the Author could be a foreign key linking to the Authors table.


### Unique key and null values

A unique key is a column or a set of columns in a table that uniquely identifies each row in that table. It is similar to a primary key, but it can contain null values and it does not have to be unique.

The main purpose of a unique key is to ensure that no two rows in a table have the same value for the unique key column(s). This is important because it prevents duplicate entries from being inserted into the table.

### Types of relations
#### One-to-One
One-to-One (1:1): Each instance of one entity is associated with only one instance of another entity.
To handle a one-to-one relationship in PostgreSQL, you can simply add a foreign key to one of the tables that references the primary key of the other table. Here's an example:

Suppose you have two tables, "employees" and "employee_details". Each employee has exactly one set of employee details, and each set of employee details belongs to exactly one employee. This is a one-to-one relationship that can be represented by adding a foreign key to the "employee_details" table that references the primary key of the "employees" table.

The "employees" table has a primary key called "id", and the "employee_details" table has a foreign key called "employee_id" that references the "id" column of the "employees" table. Here's how you can create the tables and the foreign key constraint in PostgreSQL:


```sql
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);
CREATE TABLE employee_details (
  id SERIAL PRIMARY KEY,
  employee_id INTEGER UNIQUE REFERENCES employees(id),
  salary NUMERIC(10,2),
  hire_date DATE
);
```

In this example, the "employee_details" table has a foreign key called "employee_id" that references the "id" column of the "employees" table. The UNIQUE constraint on the "employee_id" column ensures that each set of employee details is unique and belongs to exactly one employee.

To query data from these tables, you can use JOIN statements to combine the data from the two tables based on the foreign key constraint. For example, to get the name and salary of a particular employee, you can use the following query:

```sql
SELECT employees.name, employee_details.salary
FROM employees
JOIN employee_details ON employees.id = employee_details.employee_id
WHERE employees.name = 'John Doe';
```

This query uses a JOIN statement to combine data from the "employees" and "employee_details" tables based on the foreign key constraint, filtering the results by the name of a particular employee.
Similarly, to get the name and hire date of an employee given their salary, you can use the following query:


```sql
SELECT employees.name, employee_details.hire_date
FROM employees
JOIN employee_details ON employees.id = employee_details.employee_id
WHERE employee_details.salary = 50000;
 ```

This query uses a JOIN statement to combine data from the "employees" and "employee_details" tables based on the foreign key constraint, filtering the results by the salary of the employee.

	
#### One-to-Many	
One-to-Many (1:N): Each instance of one entity is associated with one or more instances of another entity. 
     you can handle a one-to-many relationship by creating a foreign key constraint on the "many" side of the relationship that references the primary key of the "one" side. Here's an example:

Suppose you have two tables: "students" and "courses". Each student can take many courses, but each course can be taken by many students. This is a many-to-many relationship that can be represented as a one-to-many relationship by introducing an intermediate table called "enrollments" that connects students to courses.

The "students" table has a primary key called "id", and the "courses" table also has a primary key called "id". The "enrollments" table has two foreign keys, one that references the "id" column of the "students" table, and another that references the "id" column of the "courses" table. Here's how you can create the tables and the foreign key constraint in PostgreSQL:

```sql
CREATE TABLE students (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE courses (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE enrollments (
  student_id INTEGER REFERENCES students(id),
  course_id INTEGER REFERENCES courses(id),
  PRIMARY KEY (student_id, course_id)
);
```

In this example, the foreign key constraint is created by adding the REFERENCES keyword to the student_id and course_id columns of the enrollments table, followed by the name of the referenced table and column. The PRIMARY KEY constraint on the enrollments table ensures that each combination of student and course is unique.
To query data from these tables, you can use JOIN statements to combine the data from multiple tables based on the foreign key constraints. For example, to get the name of the courses that a particular student is enrolled in, you can use the following query:


```sql
SELECT courses.name
FROM courses
JOIN enrollments ON courses.id = enrollments.course_id
JOIN students ON enrollments.student_id = students.id
WHERE students.name = 'John Doe';
```

This query uses JOIN statements to combine data from the courses, enrollments, and students tables, filtering the results by the name of a particular student.


#### Many-to-Many
Many-to-Many (N:M): Each instance of one entity is associated with one or more instances of another entity, and each instance of the other entity is associated with one or more instances of the first entity.
	To handle a many-to-many relationship in PostgreSQL, you can use an intermediate table with foreign key constraints that reference the primary keys of the related tables. Here's an example:

Suppose you have two tables, "students" and "courses". Each student can take many courses, and each course can be taken by many students. This is a many-to-many relationship that can be represented by introducing an intermediate table called "enrollments" that connects students to courses.

The "students" table has a primary key called "id", the "courses" table has a primary key called "id", and the "enrollments" table has two foreign keys that reference the primary keys of the "students" and "courses" tables. Here's how you can create the tables and the foreign key constraints in PostgreSQL:


```sql
CREATE TABLE students (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE courses (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255)
);

CREATE TABLE enrollments (
  student_id INTEGER REFERENCES students(id),
  course_id INTEGER REFERENCES courses(id),
  PRIMARY KEY (student_id, course_id)
);
```

In this example, the "enrollments" table has two foreign keys, one that references the "id" column of the "students" table, and another that references the "id" column of the "courses" table. The PRIMARY KEY constraint on the "enrollments" table ensures that each combination of student and course is unique.

To query data from these tables, you can use JOIN statements to combine the data from multiple tables based on the foreign key constraints. For example, to get the name of the courses that a particular student is enrolled in, you can use the following query:


```sql 
SELECT courses.name
FROM courses
JOIN enrollments ON courses.id = enrollments.course_id
JOIN students ON enrollments.student_id = students.id
WHERE students.name = 'John Doe';
```
This query uses JOIN statements to combine data from the "courses", "enrollments", and "students" tables, filtering the results by the name of a particular student.

Similarly, to get the names of the students who are enrolled in a particular course, you can use the following query:


```sql
SELECT students.name
FROM students
JOIN enrollments ON students.id = enrollments.student_id
JOIN courses ON enrollments.course_id = courses.id
WHERE courses.name = 'Calculus';
```
This query uses JOIN statements to combine data from the "students", "enrollments", and "courses" tables, filtering the results by the name of a particular course.


To create an ER model, you start by identifying the entities and their attributes, and then identifying the relationships between them. You can use various notations and symbols to represent the entities and relationships, but the basic concepts remain the same.

ER modeling is a useful tool for designing databases because it provides a clear visual representation of the relationships between different entities. It helps to ensure that the database is well-organized, with minimal redundancy and maximum efficiency, and can make it easier to modify and maintain the database over time.

#### Best practise for creating table
1. Use meaningful and consistent naming conventions for tables, columns, and other objects.
2. Create primary keys and unique constraints to ensure that each row in a table is unique and to help enforce data integrity.
3. Use foreign keys to create relationships between tables. This can help ensure data consistency and make it easier to retrieve related data.
4. Use indexes to optimize queries. Indexes can help improve the performance of search and sort operations on tables.
5. Normalize your data to reduce data redundancy and improve data integrity. Normalization involves breaking down a table into smaller tables to avoid repeating data.
6. Use appropriate data types for your columns. Choosing the right data type for a column can improve storage efficiency and help enforce data constraints.
7. Use default values and constraints to ensure that data is consistent and accurate.
8. Use comments and documentation to describe the purpose of each table and column.

### Normalization
Normalization is the process of organizing and structuring a relational database to reduce redundancy and improve data integrity. In a normalized database, each table represents a single logical entity or concept, and each piece of information is stored in only one place. This helps to avoid data inconsistencies, reduce data redundancy, and make it easier to maintain and update the database.

Normalize your tables to avoid data redundancy and ensure that each piece of data is stored only once. This can help reduce the risk of data inconsistencies and improve the performance of your queries.  Normalization is the process of organizing a database in a way that reduces data redundancy and eliminates data inconsistencies. It is an important part of designing a good table structure in PostgreSQL, as it can help improve the performance of your queries and reduce the risk of data inconsistencies. There are several levels of normalization, but the most common ones are:

2. First Normal Form (1NF): This level of normalization requires that each column in a table should contain only atomic values. In other words, each column should contain a single value, rather than a list or a group of values.
2. Second Normal Form (2NF): This level of normalization requires that a table should be in 1NF and that all non-key columns should be functionally dependent on the primary key. In other words, each non-key column should be dependent on the primary key and not on other non-key columns.
3. Third Normal Form (3NF): This level of normalization requires that a table should be in 2NF and that all non-key columns should be dependent only on the primary key, and not on other non-key columns. In other words, there should be no transitive dependencies between non-key columns.

The process of normalization involves breaking down larger tables into smaller ones and creating relationships between them using foreign keys. This can result in a larger number of tables, but it also ensures that each table contains only related information and that each piece of information is stored in only one place. This can help to improve data quality and make the database more efficient to query and update.
Normalization is an important aspect of database design and is often used in combination with other techniques, such as indexing and partitioning, to improve the performance and scalability of a database.

let's say we have a table called `orders` that looks like this:

| Order ID | Customer Name | Product Name | Product Price | Order Date |
|----------|---------------|--------------|---------------|------------|
| 1        | John Smith    | iPhone       | 1000          | 2022-01-01 |
| 2        | John Smith    | MacBook      | 2000          | 2022-01-02 |
| 3        | Jane Doe      | iPad         | 500           | 2022-01-03 |
| 4        | Jane Doe      | iMac         | 3000          | 2022-01-04 |


In this table, we can see that we have a few repeating values. For example, both John Smith's orders have the same customer name, and the product names are repeated as well. To achieve normalization, we would want to separate this table into multiple tables so that we're not repeating data unnecessarily. We could start by creating a table for `customers` that looks like this:

| Customer ID | Customer Name |
|-------------|---------------|
| 1           | John Smith    |
| 2           | Jane Doe      |

Next, we could create a table for `products` that looks like this:


Finally, we can create a table for `orders` that includes only the information that's specific to each order:

| Product ID | Product Name | Product Price |
|------------|--------------|---------------|
| 1          | iPhone       | 1000          |
| 2          | MacBook      | 2000          |
| 3          | iPad         | 500           |
| 4          | iMac         | 3000          |

Now we can see that each table includes only the information that's specific to that entity. The `orders` table includes only the order ID, the IDs of the customer and product associated with the order, and the order date. The `customers` table includes only the customer ID and name, and the `products` table includes only the product ID, name, and price. This is an example of how we can use normalization to reduce data duplication and make our database more efficient and maintainable.
